// Copyright 2014 The Go-NetCDF Authors. All rights reserved.
// Use of this source code is governed by the MIT
// license that can be found in the LICENSE file.

// These files are autogenerated from nc_double.go using generate.go
// DO NOT EDIT (except nc_double.go).

package netcdf

import (
	"fmt"
	"unsafe"
)

// #include <stdlib.h>
// #include <netcdf.h>
import "C"

// WriteUint16s writes data as the entire data for variable v.
func (v Var) WriteUint16s(data []uint16) error {
	if err := okData(v, USHORT, len(data)); err != nil {
		return err
	}
	return newError(C.nc_put_var_ushort(C.int(v.ds), C.int(v.id), (*C.ushort)(unsafe.Pointer(&data[0]))))
}

// ReadUint16s reads the entire variable v into data, which must have enough
// space for all the values (i.e. len(data) must be at least v.Len()).
func (v Var) ReadUint16s(data []uint16) error {
	if err := okData(v, USHORT, len(data)); err != nil {
		return err
	}
	return newError(C.nc_get_var_ushort(C.int(v.ds), C.int(v.id), (*C.ushort)(unsafe.Pointer(&data[0]))))
}

// WriteUint16s sets the value of attribute a to val.
func (a Attr) WriteUint16s(val []uint16) error {
	// We don't need okData here because netcdf library doesn't know
	// the length or type of the attribute yet.
	cname := C.CString(a.name)
	defer C.free(unsafe.Pointer(cname))
	return newError(C.nc_put_att_ushort(C.int(a.v.ds), C.int(a.v.id), cname,
		C.nc_type(USHORT), C.size_t(len(val)), (*C.ushort)(unsafe.Pointer(&val[0]))))
}

// ReadUint16s reads the entire attribute value into val.
func (a Attr) ReadUint16s(val []uint16) (err error) {
	if err := okData(a, USHORT, len(val)); err != nil {
		return err
	}
	cname := C.CString(a.name)
	defer C.free(unsafe.Pointer(cname))
	err = newError(C.nc_get_att_ushort(C.int(a.v.ds), C.int(a.v.id), cname,
		(*C.ushort)(unsafe.Pointer(&val[0]))))
	return
}

// ReadUint16At returns a value via index position
func (v Var) ReadUint16At(idx []uint64) (val uint16, err error) {
	var dimPtr *C.size_t
	if len(idx) > 0 {
		dimPtr = (*C.size_t)(unsafe.Pointer(&idx[0]))
	}
	err = newError(C.nc_get_var1_ushort(C.int(v.ds), C.int(v.id),
		dimPtr, (*C.ushort)(unsafe.Pointer(&val))))
	return
}

// WriteUint16At sets a value via its index position
func (v Var) WriteUint16At(idx []uint64, val uint16) (err error) {
	var dimPtr *C.size_t
	if len(idx) > 0 {
		dimPtr = (*C.size_t)(unsafe.Pointer(&idx[0]))
	}
	err = newError(C.nc_put_var1_ushort(C.int(v.ds), C.int(v.id),
		dimPtr, (*C.ushort)(unsafe.Pointer(&val))))
	return
}

// WriteUint16Slice writes data as a slice of variable v. The slice is specified by start and count:
// https://www.unidata.ucar.edu/software/netcdf/docs/programming_notes.html#specify_hyperslab.
func (v Var) WriteUint16Slice(data []uint16, start, count []uint64) error {
	if err := okDataSlice(v, USHORT, len(data), start, count); err != nil {
		return err
	}
	return newError(C.nc_put_vara_ushort(C.int(v.ds), C.int(v.id),
		(*C.size_t)(unsafe.Pointer(&start[0])),
		(*C.size_t)(unsafe.Pointer(&count[0])),
		(*C.ushort)(unsafe.Pointer(&data[0])),
	))
}

// ReadUint16Slice reads a slice of variable v into data, which must have enough
// space for all the values. The slice is specified by start and count:
// https://www.unidata.ucar.edu/software/netcdf/docs/programming_notes.html#specify_hyperslab.
func (v Var) ReadUint16Slice(data []uint16, start, count []uint64) error {
	if err := okDataSlice(v, USHORT, len(data), start, count); err != nil {
		return err
	}
	return newError(C.nc_get_vara_ushort(C.int(v.ds), C.int(v.id),
		(*C.size_t)(unsafe.Pointer(&start[0])),
		(*C.size_t)(unsafe.Pointer(&count[0])),
		(*C.ushort)(unsafe.Pointer(&data[0])),
	))
}

// WriteUint16StridedSlice writes data as a slice of variable v. The slice is specified by start, count and stride:
// https://www.unidata.ucar.edu/software/netcdf/docs/programming_notes.html#specify_hyperslab.
func (v Var) WriteUint16StridedSlice(data []uint16, start, count []uint64, stride []int64) error {
	if err := okDataStride(v, USHORT, len(data), start, count, stride); err != nil {
		return err
	}
	return newError(C.nc_put_vars_ushort(C.int(v.ds), C.int(v.id),
		(*C.size_t)(unsafe.Pointer(&start[0])),
		(*C.size_t)(unsafe.Pointer(&count[0])),
		(*C.ptrdiff_t)(unsafe.Pointer(&stride[0])),
		(*C.ushort)(unsafe.Pointer(&data[0])),
	))
}

// ReadUint16StridedSlice reads a strided slice of variable v into data, which must have enough
// space for all the values. The slice is specified by start, count and stride:
// https://www.unidata.ucar.edu/software/netcdf/docs/programming_notes.html#specify_hyperslab.
func (v Var) ReadUint16StridedSlice(data []uint16, start, count []uint64, stride []int64) error {
	if err := okDataStride(v, USHORT, len(data), start, count, stride); err != nil {
		return err
	}
	return newError(C.nc_get_vars_ushort(C.int(v.ds), C.int(v.id),
		(*C.size_t)(unsafe.Pointer(&start[0])),
		(*C.size_t)(unsafe.Pointer(&count[0])),
		(*C.ptrdiff_t)(unsafe.Pointer(&stride[0])),
		(*C.ushort)(unsafe.Pointer(&data[0])),
	))
}

// Uint16sReader is a interface that allows reading a sequence of values of fixed length.
type Uint16sReader interface {
	Len() (n uint64, err error)
	ReadUint16s(val []uint16) (err error)
}

// GetUint16s reads the entire data in r and returns it.
func GetUint16s(r Uint16sReader) (data []uint16, err error) {
	n, err := r.Len()
	if err != nil {
		return
	}
	data = make([]uint16, n)
	err = r.ReadUint16s(data)
	return
}

// testReadUint16s writes somes data to v. N is v.Len().
// This function is only used for testing.
func testWriteUint16s(v Var, n uint64) error {
	data := make([]uint16, n)
	for i := 0; i < int(n); i++ {
		data[i] = uint16(i + 10)
	}
	return v.WriteUint16s(data)
}

// testReadUint16s reads data from v and checks that it's the same as what
// was written by testWriteDouble. N is v.Len().
// This function is only used for testing.
func testReadUint16s(v Var, n uint64) error {
	data := make([]uint16, n)
	if err := v.ReadUint16s(data); err != nil {
		return err
	}
	for i := 0; i < int(n); i++ {
		if val := uint16(i + 10); data[i] != val {
			return fmt.Errorf("data at position %d is %v; expected %v", i, data[i], val)
		}
	}
	return nil
}

// testWriteUint16Slice writes somes data to v. N is v.LenDim().
// This function is only used for testing.
func testWriteUint16Slice(v Var, n []uint64) error {
	if len(n) == 0 {
		return nil // Don't test empty data.
	}
	start, count := make([]uint64, len(n)), make([]uint64, len(n))
	for i, v := range n {
		start[i] = v / 2
		count[i] = v / 2
	}
	data := make([]uint16, product(count))
	for i := 0; i < int(product(count)); i++ {
		data[i] = uint16(i + 10)
	}
	return v.WriteUint16Slice(data, start, count)
}

// testReadUint16Slice reads data from v and checks that it's the same as what
// was written by testWriteDouble. N is v.LenDim().
// This function is only used for testing.
func testReadUint16Slice(v Var, n []uint64) error {
	if len(n) == 0 {
		return nil // Don't test empty data.
	}
	start, count := make([]uint64, len(n)), make([]uint64, len(n))
	for i, v := range n {
		start[i] = v / 2
		count[i] = v / 2
	}
	data := make([]uint16, product(count))
	if err := v.ReadUint16Slice(data, start, count); err != nil {
		return err
	}
	for i := 0; i < int(product(count)); i++ {
		if val := uint16(i + 10); data[i] != val {
			return fmt.Errorf("strided slice data at position %d is %v; expected %v", i, data[i], val)
		}
	}
	return nil
}

// testWriteUint16StridedSlice writes somes data to v. N is v.LenDim().
// This function is only used for testing.
func testWriteUint16StridedSlice(v Var, n []uint64) error {
	if len(n) == 0 {
		return nil // Don't test empty data.
	}
	start, count, stride := make([]uint64, len(n)), make([]uint64, len(n)), make([]int64, len(n))
	for i, v := range n {
		start[i] = 1
		count[i] = (v - 1) / 2
		stride[i] = 2
	}
	data := make([]uint16, product(count))
	for i := 0; i < int(product(count)); i++ {
		data[i] = uint16(i + 10)
	}
	return v.WriteUint16StridedSlice(data, start, count, stride)
}

// testReadUint16StridedSlice reads data from v and checks that it's the same as what
// was written by testWriteDouble. N is v.LenDim().
// This function is only used for testing.
func testReadUint16StridedSlice(v Var, n []uint64) error {
	if len(n) == 0 {
		return nil // Don't test empty data.
	}
	start, count, stride := make([]uint64, len(n)), make([]uint64, len(n)), make([]int64, len(n))
	for i, v := range n {
		start[i] = 1
		count[i] = (v - 1) / 2
		stride[i] = 2
	}
	data := make([]uint16, product(count))
	if err := v.ReadUint16StridedSlice(data, start, count, stride); err != nil {
		return err
	}
	for i := 0; i < int(product(count)); i++ {
		if val := uint16(i + 10); data[i] != val {
			return fmt.Errorf("strided slice data at position %d is %v; expected %v", i, data[i], val)
		}
	}
	return nil
}

func testReadUint16At(v Var, n uint64) error {
	data := make([]uint16, n)
	if err := v.ReadUint16s(data); err != nil {
		return err
	}
	for i := 0; i < int(n); i++ {
		shape, _ := v.LenDims()
		coords, _ := UnravelIndex(uint64(i), shape)
		expected := data[i]
		val, _ := v.ReadUint16At(coords)
		if val != expected {
			return fmt.Errorf("data at position %v is %v; expected %v", i, val, expected)
		}
	}
	return nil
}

func testWriteUint16At(v Var, n uint64) error {
	shape, _ := v.LenDims()
	ndim := len(shape)
	coord := make([]uint64, ndim)
	for i := 0; i < ndim; i++ {
		for k := 0; k < ndim; k++ {
			coord[k] = uint64(i)
		}
		v.WriteUint16At(coord, uint16(i))
	}
	for i := 0; i < ndim; i++ {
		for k := 0; k < ndim; k++ {
			coord[k] = uint64(i)
		}
		val, _ := v.ReadUint16At(coord)
		if val != uint16(i) {
			return fmt.Errorf("data at position %v is %v; expected %v", coord, val, int(i))
		}
	}
	return nil
}
